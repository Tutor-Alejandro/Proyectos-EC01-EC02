# -*- coding: utf-8 -*-
"""Proyecto_Samsung_Merquio.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/170Yaw5eYywh-418TCpW942dPBKVVjsCt

#Importar librerias
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import kagglehub
import ipywidgets as widgets
file_path = "https://raw.githubusercontent.com/Sr-Bady/HACKEATHON_SAMSUNG_G3/refs/heads/main/SuperMarket%20Analysis.csv" #repositorio en github
products_path = "/root/.cache/kagglehub/datasets/surajjha101/bigbasket-entire-product-list-28k-datapoints/versions/1/BigBasket Products.csv"

#pf = pd.read_csv(products_path, sep=',', header=0)
#pf.head(10)

"""#CARGA DE DATOS"""

def cargar_datos(name_file):
  try:
    # Cargar la última versión del dataset como un DataFrame de pandas
    df = pd.read_csv(name_file, sep=",",header=0)
    #print("\nPrimeras 5 filas:")

  except Exception as e:
    print(f"\nOcurrió un error al cargar el dataset: {e}")
    print("Verifica si el nombre del archivo o ruta es correcto")
  print('---Informacion---')
  df.info()

  print('---Comprobacion de datos nulos---')
  null_counts = df.isnull().sum()
  print(null_counts)
  if null_counts.sum() == 0:
    print("\n   ¡Excelente noticia! No se encontraron valores nulos en el dataset.\n")
  else:
    print("\n   ¡Atención! Se encontraron valores nulos.\n")
  print('---Verificacion de duplicados---')
  print(df.drop_duplicates(inplace=True))
  ########################################### times ###############33
  # Convertir fecha con formato conocido
  date_ = df.iloc[:, 10]
  date_formatted = pd.to_datetime(date_, format="mixed")
  date_formatted.dt.strftime("%Y/%m/%d")
# Convertir hora en 12h con AM/PM
  time_ = df.iloc[:, 11]
  time_formatted = pd.to_datetime(time_, format="%I:%M:%S %p", errors="coerce").dt.time

# Unir fecha + hora
  datetime_col = pd.to_datetime(
    date_formatted.astype(str) + " " + time_.astype(str),
    format="%Y-%m-%d %I:%M:%S %p",
    errors="coerce")

# Agregar al DataFrame
  df["datetime"] = datetime_col
  df["year"] = df["datetime"].dt.year
  df["month"] = df["datetime"].dt.month
  df["week"] = df["datetime"].dt.isocalendar().week
  df["day"] = df["datetime"].dt.day
  df["weekday"] = df["datetime"].dt.day_name()  # nombre del día
  df["hour"] = df["datetime"].dt.hour
  df["semester"] = df["datetime"].dt.month.map(lambda m: 1 if m <= 6 else 2)
  df=df.sort_values(by='datetime',ascending=True)
  df=df.reset_index(drop=True)
  return df

"""#FILTROS"""

def filtrar_por_intervalo(df, tipo="mensual"):
    # Crear columnas de fecha si no existen
    if "datetime" not in df.columns:
        df["datetime"] = pd.to_datetime(df["Date"] + " " + df["Time"], errors="coerce")
    df["year"] = df["datetime"].dt.year
    df["month"] = df["datetime"].dt.month
    df["quarter"] = df["datetime"].dt.quarter

    # Usamos la columna 'Sales' como total de ventas
    if tipo == "anual":
        resumen = df.groupby("year").agg({"Sales": "sum"}).reset_index()
    elif tipo == "trimestral":
        resumen = df.groupby(["year", "quarter"]).agg({"Sales": "sum"}).reset_index()
    elif tipo == "mensual":
        resumen = df.groupby(["year", "month"]).agg({"Sales": "sum"}).reset_index()
    else:
        raise ValueError("Tipo no válido. Usa: 'anual', 'trimestral' o 'mensual'")
    return resumen

def ganancia_productos_intervalos(df):
    df = df.copy()
    df["datetime"] = pd.to_datetime(df["Date"] + " " + df["Time"], errors="coerce")
    df["year"] = df["datetime"].dt.year
    df["quarter"] = df["datetime"].dt.quarter

    # 'Product line' es el nombre del producto
    ganancia = (
        df.groupby(["year", "quarter", "Product line"])
          .agg(Ganancia_Total=("gross income", "sum"))
          .reset_index()
    )
    return ganancia

def productos_mas_vendidos(df, top=10):
    vendidos = (
        df.groupby("Product line")["Quantity"]
          .sum()
          .sort_values(ascending=False)
          .head(top).reset_index()
    )
    return vendidos

def productos_menos_vendidos(df, top=10):
    vendidos = (
        df.groupby("Product line")["Quantity"]
          .sum()
          .sort_values(ascending=True)
          .head(top).reset_index()
    )
    return vendidos

def producto_mayor_ganancia(df):
    df = df.copy()
    total_ganancia = df["gross income"].sum()
    ganancia_por_producto = (
        df.groupby("Product line")["gross income"]
          .sum()
          .reset_index()
    )
    ganancia_por_producto["Porcentaje_Ganancia"] = (
        ganancia_por_producto["gross income"] / total_ganancia
    ) * 100

    top = ganancia_por_producto.sort_values("Porcentaje_Ganancia", ascending=False).head(1)
    return top

prueba1=cargar_datos(file_path)
prueba1

print("\nGanancia trimestral:")
print(filtrar_por_intervalo(prueba1, "trimestral"))

# Ganancia por producto e intervalo
print("\nGanancia de productos por intervalos:")
print(ganancia_productos_intervalos(prueba1).head())

# Top productos más vendidos
print("\nTop 10 productos más vendidos:")
print(productos_mas_vendidos(prueba1))

# Top productos menos vendidos
print("\nTop 10 productos menos vendidos:")
print(productos_menos_vendidos(prueba1))

# Producto con mayor porcentaje de ganancia
print("\nProducto con mayor porcentaje de ganancia:")
print(producto_mayor_ganancia(prueba1))

"""#GRÁFICAS"""

# Funciones de filtrado y graficado
def aplicar_filtros_basicos(df, product_line=None, city=None, year=None, month=None):
    data = df.copy()
    if product_line and product_line != "Todos" and "Product line" in data.columns:
        data = data[data["Product line"] == product_line]
    if city and city != "Todos":
        if "City" in data.columns:
            data = data[data["City"] == city]
        elif "Branch" in data.columns:
            data = data[data["Branch"] == city]
    if year and year != "Todos" and "year" in data.columns:
        data = data[data["year"] == int(year)]
    if month and month != "Todos" and "month" in data.columns:
        data = data[data["month"] == int(month)]
    return data

def plot_top(df, nivel, by="Sales", top_n=10, title_suffix=""):
    if nivel not in df.columns:
        raise ValueError(f"Nivel '{nivel}' no existe en el DataFrame.")
    agg = df.groupby(nivel)[by].sum().sort_values(ascending=False).head(top_n)
    plt.figure(figsize=(10,6))
    agg.plot(kind="barh")
    plt.gca().invert_yaxis()
    plt.xlabel(by)
    plt.title(f"Top {top_n} por {nivel} {title_suffix}")
    plt.grid(axis="x", linestyle="--", linewidth=0.4)
    plt.tight_layout()
    plt.show()



# Función que devuelve solo columnas de texto (str) o category
def columnas_str(df, max_uniques=1000):
    cols = []
    for c in df.columns:
        try:
            if is_string_dtype(df[c]) or is_categorical_dtype(df[c]):
                # opcional: evitar columnas con demasiadas categorías que igual no sirven (ajustable)
                if df[c].nunique() <= max_uniques:
                    cols.append(c)
        except Exception:
            # en caso de fallo con el dtype, intentar inferir por tipo object
            try:
                if df[c].dtype == "object" and df[c].nunique() <= max_uniques:
                    cols.append(c)
            except Exception:
                continue
    return cols

# Interfaz interactiva que muestra SOLO columnas str como "Nivel"
def lanzar_interfaz_niveles_str(df):
    try:
        import ipywidgets as widgets
        from IPython.display import display, clear_output
        from pandas.api.types import is_string_dtype, is_categorical_dtype
        import matplotlib.pyplot as plt
        import seaborn as sns
        import numpy as np
    except Exception:
        print("ipywidgets, pandas, matplotlib, seaborn or numpy not properly imported/installed. Install with: pip install ipywidgets pandas matplotlib seaborn numpy")
        print("Then restart the kernel and execute this cell again to see the interface.")
        return

    niveles = columnas_str(df)
    if not niveles:
        print("No se encontraron columnas de texto (str o category) en el DataFrame.")
        print("Si esperabas ver alguna columna como 'Product line', conviértela a string:")
        print("  df['Product line'] = df['Product line'].astype(str)")
        return

    nivel_widget = widgets.Dropdown(options=niveles, value=niveles[0], description="Nivel (str):")
    pl_options = ["Todos"] + (sorted(df["Product line"].dropna().unique().tolist()) if "Product line" in df.columns else [])
    pl_widget = widgets.Dropdown(options=pl_options or ["Todos"], value="Todos", description="Product line:")
    city_col = "City" if "City" in df.columns else ("Branch" if "Branch" in df.columns else None)
    city_options = ["Todos"] + (sorted(df[city_col].dropna().unique().tolist()) if city_col else [])
    city_widget = widgets.Dropdown(options=city_options or ["Todos"], value="Todos", description=("City" if city_col=="City" else "Branch" if city_col else "City/Branch"))
    by_choices = [c for c in ["Sales","Quantity"] if c in df.columns]
    if not by_choices:
        raise ValueError("No se encontró columna 'Sales' ni 'Quantity' en el DataFrame.")
    by_widget = widgets.Dropdown(options=by_choices, value=by_choices[0], description="Métrica:")
    top_widget = widgets.IntSlider(value=10, min=3, max=50, step=1, description="Top N:")
    year_options = ["Todos"] + (sorted(df["year"].dropna().unique().astype(str).tolist()) if "year" in df.columns else [])
    year_widget = widgets.Dropdown(options=year_options or ["Todos"], value="Todos", description="Año:")
    month_options = ["Todos"] + (list(map(str, sorted(df["month"].dropna().unique().astype(int).tolist()))) if "month" in df.columns else [])
    month_widget = widgets.Dropdown(options=month_options or ["Todos"], value="Todos", description="Mes:")

    output = widgets.Output()

    def actualizar(change=None):
        with output:
            clear_output(wait=True)
            nivel = nivel_widget.value
            pl = None if pl_widget.value == "Todos" else pl_widget.value
            city = None if city_widget.value == "Todos" else city_widget.value
            year = None if year_widget.value == "Todos" else year_widget.value
            month = None if month_widget.value == "Todos" else month_widget.value
            by = by_widget.value
            top_n = int(top_widget.value)

            data = aplicar_filtros_basicos(df, product_line=pl, city=city, year=year, month=month)
            if data.empty:
                print("No hay datos para los filtros seleccionados.")
                return

            if by not in data.columns:
                print(f"La métrica '{by}' no existe en el DataFrame filtrado.")
                return

            try:
                title_suffix = f"(filtros: {('PL='+pl) if pl else ''} {('City='+city) if city else ''} {('year='+str(year)) if year and year!='Todos' else ''} {('month='+str(month)) if month and month!='Todos' else ''})"
                plot_top(data, nivel, by=by, top_n=top_n, title_suffix=title_suffix)
            except Exception as e:
                print("Error al graficar:", e)

    for w in [nivel_widget, pl_widget, city_widget, by_widget, top_widget, year_widget, month_widget]:
        w.observe(actualizar, names='value')

    controls_top = widgets.HBox([nivel_widget, by_widget, top_widget])
    controls_bottom = widgets.HBox([pl_widget, city_widget, year_widget, month_widget])
    display(controls_top, controls_bottom, output)

    actualizar()

# Ejecutar interfaz
# lanzar_interfaz_niveles_str(prueba1) # This line will be moved to the next cell

"""# RESULTADOS"""

# Now execute the interface with the loaded data
lanzar_interfaz_niveles_str(prueba1)

# @title
# Group by month and calculate total sales and total COGS for each month
monthly_sales_cogs = prueba1.groupby('month')[['Sales']].sum().reset_index()

# Melt the DataFrame for plotting
monthly_sales_cogs_melted = monthly_sales_cogs.melt('month', var_name='Metric', value_name='Amount')

# Create the bar plot
plt.figure(figsize=(10, 6))
sns.barplot(x='month', y='Amount', hue='Metric', data=monthly_sales_cogs_melted)
plt.title('Ventas Mensuales vs COGS Mensuales')
plt.xlabel('Mensuales')
plt.ylabel('Cantidad')
plt.xticks(rotation=0)
plt.show()

# @title
# Visualize Average Sales by Product Line, colored by Risk Category
merged_df = prueba1.groupby('Product line').agg(
    Total_Sales=('Sales', 'sum'),
    Average_Sales=('Sales', 'mean'),
    Average_Rating=('Rating', 'mean'),
    Seasonality_Std_Sales=('Sales', 'std')
).reset_index()

# Risk Category
min_media = merged_df['Average_Sales'].min()
merged_df['Risk_Category'] = merged_df['Average_Sales'].apply(
    lambda x: 'En Riesgo' if x == min_media else 'Sin Riesgo'
)


# Visualize Average Rating by Product Line, colored by Risk Category
plt.figure(figsize=(8, 4))
sns.barplot(x='Product line', y='Average_Rating', hue='Risk_Category', data=merged_df, palette='viridis')
plt.title('Average Rating by Product Line (Risk Category)')
plt.xlabel('Product Line')
plt.ylabel('Average Rating')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# Visualize Seasonality (Std Dev of Monthly Sales) by Product Line, colored by Risk Category
plt.figure(figsize=(12, 6))
sns.barplot(x='Product line', y='Seasonality_Std_Sales', hue='Risk_Category', data=merged_df, palette='viridis')
plt.title('Seasonality (Std Dev of Monthly Sales) by Product Line (Risk Category)')
plt.xlabel('Product Line')
plt.ylabel('Standard Deviation of Monthly Sales')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# @title
# Analyze 'Sales' and 'Quantity' as potential metrics for "Demanda"
#print("Sales column description:")
#print(prueba1['Sales'].describe())
#print("\nQuantity column description:")
#print(prueba1['Quantity'].describe())

# Based on the descriptions, both Sales (total revenue) and Quantity (number of units sold)
# can represent demand. Let's use Sales for now as it reflects the monetary value of demand.

# Aggregate Sales by month
monthly_demand = prueba1.groupby(['Product line','month'])['Sales'].sum().reset_index()
# Visualize monthly demand
plt.figure(figsize=(10, 6))
sns.lineplot(x='month', y='Sales', data=monthly_demand, hue = 'Product line')
plt.title('Monthly Demand (Sales)')
plt.xlabel('Month')
plt.ylabel('Total Sales')
plt.xticks(monthly_demand['month'])
plt.grid(axis='y', linestyle='--', linewidth=0.7)
plt.show()

#PIE CHART: SALES BY MONTH

def plot_pie(mes):
    df_filtrado = prueba1[prueba1['month'] == mes]
    product_sales = df_filtrado.groupby('Product line')['Sales'].sum()
    valores = product_sales.values
    etiquetas = product_sales.index
    plt.figure(figsize=(8, 8))
    plt.pie(x=valores,
            labels=etiquetas,
            autopct='%1.1f%%',
            startangle=90,
            colors=sns.color_palette('pastel'))

    plt.title(f'Product line s sales by month {mes}')
    plt.ylabel('')
    plt.show()

# Lista de meses disponibles
mes = sorted(prueba1['month'].unique())

filtro_mes = widgets.Dropdown(
    options=mes,
    value=mes[0],
    description='Seleccionar Mes:',
)

# Conectar el widget a la función
widgets.interactive(plot_pie, mes=filtro_mes)


rating_df = prueba1.groupby(['Customer type', 'Gender', 'Product line'])['Rating'].agg(
    Average_Rating='mean'
).reset_index()

# Configurar el estilo de Seaborn (opcional)
sns.set_theme()

def plot_radar(tipo_filtro):
    # Usar el DataFrame agrupado como fuente
    labels = rating_df['Product line'].unique()
    num_vars = len(labels)

    # Calcular los ángulos para cada punta
    angles = np.linspace(0, 2 * np.pi, num_vars, endpoint=False).tolist()
    angles += angles[:1] # Cierra el círculo

    # Configurar el subplot para el gráfico polar
    fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(polar=True))
    ax.set_theta_offset(np.pi / 2)
    ax.set_theta_direction(-1)

    # Dibujar un polígono para cada categoría del filtro seleccionado
    categorias = rating_df[tipo_filtro].unique()
    for categoria in categorias:
        # Filtrar el DataFrame agrupado por el tipo y categoría seleccionados
        df_categoria = rating_df[rating_df[tipo_filtro] == categoria]

        # Unir los datos en el orden correcto de las etiquetas
        # y usar la columna 'Average_Rating'
        values = df_categoria.groupby('Product line')['Average_Rating'].mean().reindex(labels).fillna(0).tolist()
        values += values[:1]

        ax.plot(angles, values, linewidth=2, linestyle='solid', label=categoria)
        ax.fill(angles, values, alpha=0.25)

    # Configurar las etiquetas de las puntas
    ax.set_thetagrids(np.degrees(angles[:-1]), labels)

    # Configurar las etiquetas de los valores
    ax.set_rgrids(np.arange(0, 11, 2), color="gray", size=10)
    ax.set_ylim(0, 10) # Escala de calificación de 0 a 10

    plt.title(f'Rating promedio por línea de producto por {tipo_filtro}')
    plt.legend(loc='upper right', bbox_to_anchor=(0.1, 0.1))
    plt.show()

# Lista de opciones para el menú desplegable
opciones_filtro = ['Gender', 'Customer type']

# Crear el widget Dropdown
filtro_selector = widgets.Dropdown(
    options=opciones_filtro,
    # Asignar un valor inicial válido, como la primera opción
    value=opciones_filtro[0],
    description='Filtrar por:',
)

# @title
interactivo_pie = widgets.interactive(plot_pie, mes=filtro_mes)

interactivo_radar = widgets.interactive(plot_radar, tipo_filtro=filtro_selector)

contenedor_widgets = widgets.VBox([interactivo_pie, interactivo_radar])
display(contenedor_widgets)